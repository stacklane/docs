<!--TEMPLATE mustache-->
{{% partial /_layout }}

{{< layout}}

{{$title}}Endpoints{{/title}}

{{$content}}

<article>
    <header>
        <h1>Endpoint Overview</h1>

        <p>
           Learn how to structure files and folders into REST endpoints and views.
        </p>
    </header>

    <section>
        <p>
        Files and folders in your source code closely match the
        resulting RESTful paths and endpoints.
        </p>

        <p>
        The main types of endpoints supported include
        <a href="/endpoints/js">Server-Side JavaScript</a>,
        <a href="/endpoints/mustache">Mustache HTML Views</a>,
        and
        <a href="/endpoints/assets">assets (images and SASS/SCSS)</a>
        </p>
    </section>

    <section>
        <h2><a name="dynamic">Dynamic Paths</a></h2>

        <p>
            In many cases with data-driven content, URLs are dynamic &dash;
            they are backed by a model field, such as its ID, or other
            unique field.  To indicate that part of an endpoint path
            is dynamic, use a named placeholder:
        </p>

        <p>
            <code>/article/{article}/index.html</code>
        </p>

        <p>
            By itself this is invalid.
            Next tell Stacklane the types of values allowed for this dynamic parameter.
            Drop a settings file into <code>/article/{article}/ðŸ”—.yaml</code>.
            This settings file indicates how the dynamic parameter <code>{article}</code>
            is translated into an actual value.
        </p>

        <p>
            For the value in this settings file, choose <b>one</b> of the following options:
        </p>

        <h3>Model-Backed Dynamic Paths</h3>

        <p>
            A single model field may be referenced.
            The field may be the model's unique ID, or a <a href="/models/fields#uid">UID field</a>.
        </p>

        <p>
        <pre class="language-yaml"><code>
field: ðŸ“¦.Task.id
    </code></pre>
        </p>

        <p>
            If the model can't be found, it will result in a standard not found <a href="/endpoints/errors">error</a>.
            From a scripting and template standpoint, these are exported as "links" to the model.
            These links are not a live model, but a pointer or reference to the model.
            Basic properties from the live object are cached on the link for up to 10 minutes.
            If you only need to read properties, and a certain amount of staleness is acceptable,
            then use these properties instead of loading the live model.
        </p>

        <p>
        <pre class="language-javascript"><code>
import {task} from 'ðŸ”—';

// Access the task's cached 'title'
let title = task.title;

// Or get a live version of the task by calling get() on the link
title = task.get().title;
    </code></pre>
        </p>

        <p>
            Often dynamic paths are used with <a href="/models/containers">containers</a>.
            In this case it's not necessary to load a live version to "use" the container.
        </p>

        <p>
        <pre class="language-javascript"><code>
import {list} from 'ðŸ”—';
import {Task} from 'ðŸ“¦';

// Return all of the tasks for the cached list
list(()=>Task.all());
    </code></pre>
        </p>


        <h3>Fixed Value Dynamic Paths</h3>

        <p>
            Indicates that a set of strings are valid for this path parameter.
            These must be valid URL identifiers (see more information on
            <a href="/models/fields#uid">formatting URL identifiers</a>).
        </p>

        <p>
        <pre class="language-yaml"><code>
values:
- option-one
- another-option
- etc
    </code></pre>
        </p>

        <p>
            Fixed values paths are exposed to scripting and templates
            in two different ways.
        </p>
        <p>
        <pre class="language-javascript"><code>
import {thePathVar} from 'ðŸ”—';

// Directly access the value
if (thePathVar.$value == 'option-one'){
    ...
}

// Boolean switch
if (thePathVar['option-one']){
    ...
}
    </code></pre>
        </p>
    </section>

    <section>
        <h2><a name="private">Private Files</a></h2>

        <p>
            Any file prefixed with an underscore <code>_fileName.html</code>
            will never be publicly accessible, and is only used for
            server side includes or similar logic (for example SASS or Mustache partial).
        </p>

        <p>
            Similarly any files whose <b>direct</b> parent folder
            has an underscore such as <code>/_files/something.html</code>,
            will be considered private even if the files themselves are not prefixed
            with an underscore.
        </p>
    </section>

</article>

{{/content}}
{{/layout}}
