<!--TEMPLATE mustache-->
{{% partial /_layout }}

{{< layout}}

{{$title}}Mustache Endpoints{{/title}}

{{$content}}

<article>
    <header>
        <h1>Mustache Endpoints</h1>

        <p>
           Learn how to use Mustache to create HTML views.
        </p>
    </header>

    <section>
        <h2><a name="overview">Overview</a></h2>
        <p>
            Stacklane uses Mustache, combined with additional extensions (pragmas),
            to create dynamic HTML views.
        </p>
        <p>
            To use Mustache to generate HTML views, continue to use the ".html" extension,
            and on the first line of the HTML file use the special comment:
        </p>
        <p>
            <code>&lt;!--TEMPLATE mustache--&gt;</code>
        </p>
        <p>
            All files that use Mustache for the templating language, including partials/imports,
            must include on the first line.
        </p>
        <p>
            Mustache views may be populated with data or other scripted variables
            by importing <a href="#variables">variables</a> previously exported by
            <a href="/scripting/suppliers">Suppliers</a>.
        </p>
    </section>

    <section>
        <h2><a name="routing">Routing</a></h2>

        <p>
            Mustache endpoints are routed according to their file name.
        </p>
        <p>
            For example, <code>/hello/world.html</code>
            responds to requests for <code>GET /hello/world</code>.
        </p>
        <p>
            <code>index.html</code> may be used in the case where
            the routing should be directory based.  <code>/hello/index.html</code>
            responses to requests for <code>GET /hello/</code>.
            <i>Note: It will also respond to requests for <code>GET /hello</code> (no trailing slash),
            and redirect to the actual endpoint of <code>/hello/</code> (trailing slash).</i>
        </p>
    </section>

    <section>
        <h2><a name="links">Link Absolute Paths</a></h2>

        <p>
            When referencing files or endpoints within your app
            we highly recommend using "href" and "src" with
            absolute values instead of relative values --
            <code>href=&quot;/here/there&quot;</code> instead of
            <code>href=&quot;here/there&quot;</code>.
        </p>
        <p>
            This creates consistency in a number of other locations including
            script redirects, Mustache partial imports, and in
            general leaves no ambiguity.
        </p>
    </section>

    <section>
        <h2><a name="partials">Partials</a></h2>

        <p>
            Mustache partials may be thought of as file includes.
            The syntax for including a partial is <code>&#123;&#123;> nameOfPartial&#125;&#125;</code>.
        </p>
        <p>
            By default there are no partials available.  Stacklane uses pragmas to
            instruct what partials are available, and how they are named.
        </p>

        <h3>Directory of Partials</h3>
        <p>
            Name the directory with a leading underscore to indicate it is private:
            <code>/_partials/</code>.  To allow the individual Mustache files in the directory
            to be used as partials, use the pragma <code>&#123;&#123;% partial /_partials/ &#125;&#125;</code>
            (note the trailing slash).  Given a file in this directory <code>/_partials/something.html</code>,
            it may then be included via the standard syntax <code>&#123;&#123;> something&#125;&#125;</code>.
        </p>
        <p>
            A directory of partials may optionally be given a prefix.  Using the above example,
            <code>&#123;&#123;% partial /_partials/ as my&#125;&#125;</code>
            brings in those partials with the "my-" prefix (hyphen is implied).
            The same partial is now included using
            <code>&#123;&#123;> my-something&#125;&#125;</code>
        </p>

        <h3>Single Files</h3>
        <p>
            A single partial may be imported by referencing its full path name without the
            ".html" extension.  <code>&#123;&#123;% partial /_partials/something &#125;&#125;</code>
            is accessible via <code>&#123;&#123;> something&#125;&#125;</code>.
        </p>
        <p>
            Single file partials also support aliases.
            <code>&#123;&#123;% partial /_something as somethingElse &#125;&#125;</code>
            is accessible via <code>&#123;&#123;> somethingElse&#125;&#125;</code>.
        </p>
    </section>

    <section>
        <h2><a name="svg">SVG</a></h2>
        <p>
            SVG files may be included/inlined using the same nomenclature as Mustache partials.
            The only difference is the initial pragma.
        </p>
        <p>
            Given a directory of SVG icons, the pragma
             <code>&#123;&#123;% svg /_icons/ as ic &#125;&#125;</code> would allow
            importing of gear.svg using <code>&#123;&#123;> ic-gear&#125;&#125;</code>.
        </p>
    </section>

    <section>
        <h2><a name="layout">Layout Templates</a></h2>

        <p>
            A common extension to Mustache is the ability to define a "master template".
            This file contains the <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>,
            and <code>&lt;body&gt;</code> tags.  Within the file there is at least one
            placeholder which denotes where to "insert" a section of HTML from another Mustache file
            (the file which uses this master layout template).
        </p>
        <h3>Master Template</h3>
        <p>
        <pre><code class="language-html">
&lt;!--TEMPLATE mustache--&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&#123;&#123;$title&#125;&#125;Title&#123;&#123;/title&#125;&#125;&lt;/title&gt;
...
&lt;/head&gt;
&lt;body&gt;
...
&#123;&#123;$content&#125;&#125;Content&#123;&#123;/content&#125;&#125;
...
&lt;/body&gt;
&lt;/html&gt;
        </code></pre>
        </p>
        <h3>Template Using Layout</h3>
        <p>
            The file using the master layout template will include it similar to a partial.
            Assuming a layout file named <code>/_layout.html</code>, another file
            would use this template like:
        <pre><code class="language-html">
&lt;!--TEMPLATE mustache--&gt;
&#123;&#123;% partial /_layout&#125;&#125;

&#123;&#123;&lt;layout&#125;&#125;
&#123;&#123;$title&#125;&#125;My Title&#123;&#123;/title&#125;&#125;
&#123;&#123;$content&#125;&#125;
.. Custom Content Here ..
&#123;&#123;/content&#125;&#125;
&#123;&#123;/layout&#125;&#125;
    </code></pre>
        </p>
    </section>

    <section>
        <h2><a name="json">JSON</a></h2>

        <p>
            In certain cases it helps to keep structured data outside of your Mustache file,
            and then include this for processing as any other variable.
            This might make sense when a <a href="/models/types">model type</a> is overkill,
            or its specs are still being mocked up.
        </p>
        <p>
            In this case you can define a JSON file with a list of objects, and then refer to it as
            you would any partial:  <code>&#123;&#123;% json /_myData as myData &#125;&#125;</code>.
            This list of objects may then be iterated using Mustache iteration tags.
        </p>
        <!--
            TODO Example
        -->
    </section>

    <section>
        <h2><a name="util">Utilities</a></h2>

        <h3>choose-string</h3>

        <p>
            Provides a declarative way to choose one string based on another string.
            If it were defined programmatically it would be a series of simple if/then/else,
            or switch/case/default statements.
            This is especially useful when dealing with constant, well-defined values
            for a model field.
        </p>

        <p>
            First, declare the string choices using <code>choose-string-map</code>.
        </p>

        <pre><code class="language-html">
&#123;&#123;% choose-string-map message error=alert-danger *=alert-* &#125;&#125;
    </code></pre>

        <p>
            The first parameter of <code>message</code> defines a name of the string choice,
            which will be repeated later for <code>choose-string</code>.
            The remaining parameters define the mapping of input strings to output strings,
            with an optional capture of the input via "*".
        </p>

        <p>
            The above example outputs "alert-danger" when the string input is "error".
            A catch all / else case may defined with "*".
            In the example above an input of "success" would result in "alert-success".
            For any of the cases, "*" is available to fill in the existing string input.
        </p>

        <p>
            Second, use the previously defined string map.
            The first parameter repeats the name given to the string map,
            and the second parameter is the string input.
        </p>

        <pre><code class="language-html">
&#123;&#123;#Messages.all&#125;&#125;
&lt;div class="notification &#123;&#123;% choose-string message this.type &#125;&#125;"&gt;
  &#123;&#123;this.value&#125;&#125;
&lt;/div&gt;
&#123;&#123;/Messages.all&#125;&#125;
        </code></pre>

        <h3>Alternative Definition</h3>

        <p>
            <code>choose-string-map</code> is the most compact way to define the choices.
            However if spaces are needed in the strings use JSON for the definition via
            <code>choose-string-json</code>.
        </p>

        <pre><code class="language-html">
&#123;&#123;% choose-string-json message
  {
    "error": "alert alert-danger",
     "*": "alert alert-*"
  }
&#125;&#125;
    </code></pre>
    </section>

    <section>
        <h2><a name="iteration">Iteration Extensions</a></h2>
        <p>
            We've extended Mustache iteration with a couple of helpful utilities.
            Standard mustache iteration looks like
            <code>&#123;&#123;#SomeList&#125;&#125; ... &#123;&#123;/SomeList&#125;&#125;</code>.
            There are two additional iteration options:
        </p>
        <h3>as</h3>
        <p>
            Use 'as' to rename the internal variable available in each iteration:

            <code>&#123;&#123;#SomeList as item&#125;&#125; &#123;&#123;item.prop&#125;&#125; &#123;&#123;/SomeList&#125;&#125;</code>
        </p>
        <h3>by</h3>
        <p>
            Use 'by' to iterate the collection in groups of N (up to 10).

            This is most useful when working with various CSS grid layouts.

            <pre><code class="language-html">
&#123;&#123;#SomeList by 2 as grp&#125;&#125;
    &#123;&#123;#grp as item&#125;&#125;
        &#123;&#123;item.prop&#125;&#125;
    &#123;&#123;/grp&#125;&#125;
&#123;&#123;/SomeList&#125;&#125;
    </code></pre>

        </p>
    </section>

    <section>
        <h2><a name="variables">Variable Imports</a></h2>

        <p>
            Mustache views may import variables which were exported by <a href="/scripting/suppliers">Suppliers</a>.
            To import a variable (or variables) use the following pragma:
        </p>
        <p>
            <code>&#123;&#123;% import {SomeVar, AnotherVar} from '📤' &#125;&#125;</code>
        </p>
        <p>
            After importing, <code>&#123;&#123;SomeVar&#125;&#125;</code> may then be used anywhere within the Mustache view.
        <p>
        <p>
            (As mentioned in the documentation on <a href="/scripting/suppliers">Suppliers</a>,
            all variables exported exist in the module '📤'.)
        </p>

        <h3>HTML Encoding/Escapes</h3>
        <p>
            Mustache escapes / encodes special HTML characters by default when they
            are included from a variable or model field.  If <code>&#123;&#123;company.name&#125;&#125;</code>
            is "ABC &amp; Co.", then this will become the encoded HTML equivalent  <code>ABC &amp;amp; Co.</code>.
        </p>
    </section>

    <section>
        <h2><a name="soc">Separation of Concerns</a></h2>

        <p>
            If there are developers on a team who are strictly working on Mustache views, it may be useful to
            limit their access to specific <a href="/scripting/suppliers">Supplier</a> values.
        </p>
        <p>
            This can be accomplished by creating a <a href="/scripting/suppliers#strict">pinned supplier</a> file
            within the same directory as the Mustache view.
        </p>
        <p>
            For example, given a Mustache view of <code>/hello/world.html</code>, and a Supplier file of
            <code>/hello/📤📌world.js</code>, the Mustache view will only have access to
            values exported by <code>/hello/📤📌world.js</code>, regardless of any other Supplier's in the path.
        </p>
    </section>

    <section>
        <h2><a name="csp">Content Security Policies (CSP)</a></h2>

        <p>
            All pages served by Stacklane are given a Content Security Policy (CSP).
            The CSP header allows a host to declare trusted sources of content (JS execution, CSS styles, images etc).
        </p>

        <h3>Automatic Behavior</h3>

        <p>
            Files are analyzed to create a reasonable CSP file.

        <ul>
            <li><code>&lt;script src=" ... &gt;</code></li>
            <li><code>&lt;link rel="stylesheet" href=" ... &gt;</code></li>
            <li>Inline <code>&lt;script&gt;</code> elements become a CSP hash source.</li>
            <li>Inline <code>&lt;style&gt;</code> elements become a CSP hash source.</li>
        </ul>
        </p>

        <h3>Custom Declarations</h3>

        <p>
            Include the following tag anywhere in the body:

        <pre><code class="language-html">
&lt;link itemprop="content-security-policy" ... &gt;
        </code></pre>

        This tag supports the following properties:

        <ul>
            <li><code>data-connect-self="true"</code> - allows AJAX connections to the same web app.</li>
            <li><code>data-img-src-data="true"</code> - allows "data:" as an image source in CSS.</li>
        </ul>
        </p>

        <h3>Restrictions</h3>
        <p>
        <ul>
            <li>
                Inline style attributes <code>style="..."</code> are not allowed.
            </li>
            <li>
                Inline JavaScript via attributes <code>onclick="..."</code>, etc, are not allowed.
            </li>
        </ul>
        </p>
    </section>
</article>

{{/content}}
{{/layout}}
