<!--TEMPLATE mustache-->
{{% partial /_layout }}

{{< layout}}

{{$title}}Users{{/title}}

{{$content}}

<article>
    <header>
        <h1>Users</h1>

        <p>
            This configuration is only needed to enable user and/or session functionality.
        </p>
    </header>

    <section>
        <p>
            To enable user or session functionality drop a settings file into
            the root named <code>/ðŸ‘¤.yaml</code>.
            After learning about the settings and related concepts involved,
            check out the closely related <a href="/scripting/users">user scripting</a>.
        </p>
    </section>

    <section>
        <h2><code><a name="auth">auth</a></code></h2>

        <p>
            Predefined string which specifies the overall authentication
            mode of the site.  Default: <code>inherit</code>
        </p>

        <table class="table">
            <thead>
            <tr>
                <th scope="col">Value</th>
                <th scope="col">Description</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><code>inherit</code></td>
                <td>Default. If the site is nested, inherit the parent site's user behavior, otherwise <code>none</code>.</td>
            </tr>
            <tr>
                <td><code>none</code></td>
                <td>Explicitly disabled user and/or session functionality.</td>
            </tr>
            <tr>
                <td><code>required</code></td>
                <td>The entire site is private access only, requiring user authentication for all endpoints.</td>
            </tr>
            </tbody>
        </table>

        <p>
            What if you have a site that is partially public and partially user access <code>required</code>?
            In this case use a <a href="/settings/nested">nested site</a> for the <code>required</code> auth access.
            This will keep the development of each cleanly separated by purpose.
            If they share look and feel, there may be some duplication of style assets, however
            in the long run this minor duplication will be worth it.
        </p>
    </section>

    <section>
        <h2><code><a name="roles">role</a></code></h2>

        <div class="alert alert-info small" role="alert">
            Changing role names may not be a safe operation if the role has been associated with a user.
        </div>

        <p>
            Roles contain 0 or more permission rules.
            Permission rules define what is allowed for a role.
            Most commonly permission rules map to model data operations.
            If a role contains 0 rules, it can be considered an identifier or placeholder.
        </p>
        <p>
            Scripts and templates code against role names.
            In other words:  "Is role ABC active for the current user/session".
            The permission rules that a role contains consists
            of two parts: 1) Resource Rule, 2) Operation(s) Allowed
        </p>

        <pre class="language-yaml"><code>
role:
  [ROLE_NAME]:
    [RESOURCE_RULE]: [OPERATIONS_ALLOWED]
    </code></pre>

        <p>Or:</p>

        <pre class="language-yaml"><code>
role:
  [ROLE_NAME]: [OPERATIONS_ALLOWED]
    </code></pre>

        <h6>Resource Rule</h6>
        <p>
            Resource rules for models simply follow the data structure, from general to specific.
        </p>

        <pre class="language-yaml"><code>
ðŸ“¦
ðŸ“¦.Task
ðŸ“¦.Task.name
    </code></pre>

        <h6>Operation Names</h6>
        <p>
            The available permission operations are:
            <code>none</code>,
            <code>all</code>,
            <code>access</code>,
            <code>read</code>,
            <code>create</code>,
            <code>update</code>,
            <code>delete</code>,
            <code>state</code>
        </p>
        <p>
            <!--Most operations map directly to an HTTP method.
            For predictable handling of endpoints that need to be role-constrained,
            we recommend following this general pattern.-->
            Not all operations are applicable to all resources.
        </p>

        <table class="table">
        <thead>
        <tr>
            <th scope="col">Operation</th>
            <th scope="col">Description</th>
            <!--th scope="col">HTTP</th-->
        </tr>
        </thead>
        <tbody>
        <tr>
            <td><code>all</code></td>
            <td>All operations are allowed.</td>
            <!--td></td-->
        </tr>
        <tr>
            <td><code>access</code></td>
            <td>
                Access operations are allowed.
                <br>
                <small>May also refer to "select", "exists", "accessible", or "visible".</small>
            </td>
            <!--td><b>GET</b></td-->
        </tr>
        <tr>
            <td><code>read</code></td>
            <td>
                Read operations are allowed.
                <br>
                <small>May also refer to "get", "load".</small>
            </td>
            <!--td><b>GET</b></td-->
        </tr>
        <tr>
            <td><code>create</code></td>
            <td>Create operations are allowed</td>
            <!--td><b>POST</b></td-->
        </tr>
        <tr>
            <td><code>update</code></td>
            <td>
                Update operations are allowed.
                <br>
                <small>May also refer to "editing" or "modifying" something that already exists.</small>
            </td>
            <!--td><b>PUT</b></td-->
        </tr>
        <tr>
            <td><code>delete</code></td>
            <td>Delete operations are allowed.
                <br>
                <small>May also refer to quasi-deletes, such as an operation that could be rolled back.</small>
            </td>
            <!--td><b>DELETE</b></td-->
        </tr>
        <tr>
            <td><code>state</code></td>
            <td>State change operations are allowed.
                <br>
                <small>
                Special case of a field value <code>update</code>,
                representing a significant "change in state".
                This occurs by nomenclature, for any field named
                "state", "status", "stage", or "lifecycle".
                </small>
            </td>
            <!--td><b>PATCH</b></td-->
        </tr>
        <tr>
            <td><code>list</code></td>
            <td>
                List operations are allowed.
                <br>
                <small>List operations are "bulk" operations, and may refer to queries, or
                anything that returns or operates on <i>potentially</i> multiple results.
                </small>
            </td>
            <!--td></td-->
        </tr>
        </tbody>
        </table>

        <h6>Full Role Example</h6>
        <p>
            The rule most specific to the requested resource will be used.
            Rules do not aggregate or combine.
            More general rules simply provide defaults when a more specific rule does not exist.
        </p>
        <p>
        <pre class="language-yaml"><code>
role:
  Admin:
    ðŸ“¦: all
  TaskEditor:
    ðŸ“¦.Task: create,read,update,list
    ðŸ“¦.Task.status: none
    </code></pre>
        </p>

        <h6>Naming Recommendations</h6>
        <p>
            Names must start with an uppercase character and be valid identifiers.
            We recommend using a singular form for role names.
        </p>
    </section>

    <section>
        <h2><code><a name="default">default</a></code></h2>

        <div class="alert alert-info small" role="alert">
            For most cases with user-enabled sites we do not recommend setting a value for this.
            This ensures that your custom roles start from a blank slate,
            since the default for this value is <b>none</b>.
        </div>

        <p>
            A special role type that is <i>always</i> in effect &mdash;
            for all authenticated <i>and</i> unauthenticated users.
        </p>

        <pre class="language-yaml"><code>
default:
  [RESOURCE_RULE]: [OPERATIONS_ALLOWED]
    </code></pre>

        <p>Or:</p>

        <pre class="language-yaml"><code>
default: [OPERATIONS_ALLOWED]
    </code></pre>

        <p>
            For example, to make everything readable by default:
        </p>

        <pre class="language-yaml"><code>
default: read
    </code></pre>

        <p>
            Take care with the default rule since permissions may only be granted, never revoked.
            In other words you can't create another role that reduces the permissions given
            by the <code>default</code> role.
        </p>

        <p>
            If there is no user configuration file defined, then this role is effectively:
        </p>

        <pre class="language-yaml"><code>
default: all
    </code></pre>

        <p>
            When a user configuration file <i>is</i> defined, but this role is not specified in the file,
            then it is effectively <code>none</code>, which ensures
            that custom roles start with a blank slate.
        </p>

        <pre class="language-yaml"><code>
default: none
    </code></pre>

    </section>

    <section>
        <h2><code><a name="sub">Sub-Directories</a></code></h2>

        <p>
            By default the root ðŸ‘¤.yaml impacts all files and descendant directories.
        </p>
        <p>
            Additional user settings files (ðŸ‘¤.yaml) may be selectively placed in sub-directories.
            Use this functionality to grant / revoke / modify the permission rules for specific
            roles or the <code>default</code> role.
            As with the root file, settings in a sub-directory file are in scope for all descendants,
            unless another ðŸ‘¤.yaml  is specified, in which case that begins a new scope.
        </p>
        <p>
            When using sub-directory files to define a new permission scope, any role names
            specified must already be defined in the root settings file.
            In other words you can't use a sub-directory file to create a new role, only
            redefine an existing role.
            As with the root file, everything defaults to <code>none</code>,
            and you must explicitly redefine rules for that sub-directory.
        </p>
    </section>

    <!--
    <section>
        <h2><code><a name="assign">Assigning Roles</a></code></h2>

        <p>

        </p>
    </section>
    -->

    <section>
        <h2><code><a name="resolving">Resolving</a></code></h2>

        <p>
            To check access permissions, such as loading a specific
            model instance <code>let prod = Product.get('[id]')</code>,
            the platform will check:
        </p>

        <ul>
            <li><code>access</code> <code>ðŸ“¦.Product</code>?</li>
            <li><code>read</code> <code>ðŸ“¦.Product.id</code>?</li>
        </ul>

        <p>
            Assuming the <code>Product</code> is found,
            next it will check whether the user has any roles
            specific to that unique product instance.
            These roles will be brought into scope
            only while accessing the specific product.
        </p>

        <p>
            As additional operations on the product are performed,
            such as <code>product.title = 'New Title'</code>,
            the system will use all in-scope roles to determine:
        </p>

        <ul>
            <li><code>update</code> <code>ðŸ“¦.Product.title</code>?</li>
        </ul>

        <h3>In-Scope Roles</h3>

        <p>
            To determine whether a specific operation is possible,
            the platform is considering a combination of permission
            rules as follows:
        </p>
        <ul>
            <li>ðŸ‘¤.yaml <code>default</code> role.</li>
            <li>Roles assigned to the authenticated user.</li>
            <li>Roles assigned between authenticated user and a specific model instance.</li>
            <li>Roles assigned between authenticated user and a model's parent + ancestor <a href="/models/containers">containers</a>.</li>
        </ul>
        <p>
            As we are only concerned with granting permissions,
            if multiple roles are in effect then the final effective role is a combination of all
            assigned and in-scope roles.
        </p>
        <p>
            It's also important to keep in mind the first step of the process.
            For this process ðŸ‘¤.yaml is referring to the currently in-scope
            settings file, which may be a sub-directory file.
            In this way both revocation and super-user scenarios
            are possible simply redefining roles for specific sub-directories.
        </p>
    </section>
</article>


{{/content}}
{{/layout}}