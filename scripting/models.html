<!--TEMPLATE mustache-->
{{% partial /_layout }}

{{< layout}}

{{$title}}Model Scripting{{/title}}

{{$content}}

<article>
    <header>
        <h1>Model Scripting</h1>

        <p>
            Learn about scripting with <a href="/models/">data models</a>.
        </p>
    </header>

    <section>
        <h2><a name="crud">CRUD</a></h2>

        <h3>Create</h3>
        <p>
        <pre><code class="language-javascript">
let newList = new List().title('x');
        </code></pre>
        </p>

        <h3>Read</h3>
        <p>
        <pre><code class="language-javascript">
let listId = '...';
let list = List.get(listId);
// Because of error handling, 'list' is always defined at this point
let listTitle = list.title;
        </code></pre>
        </p>

        <h3>Update</h3>
        <p>
        <pre><code class="language-javascript">
let listId = '...';
List.get(listId).title = 'new title'; // field/property setter
new List().title('new title').otherField('value'); // fluent setter
        </code></pre>
        </p>

        <h3>Delete</h3>
        <p>
        <pre><code class="language-javascript">
let listId = '...';
List.get(listId).remove();
        </code></pre>
        </p>
    </section>

    <section>
        <h2><a name="containers">Containers</a></h2>

        <p>
            Since <a href="/models/#containers">containers</a> create a "scope" for
            working with other data, a container must be selected
            before any other operations on its contained data.
        </p>
        <p>
            To execute code in the context of selected container, pass a function
            to the container's variable.  The return value of the function
            will be passed back as the return value of selecting the container.
            Example:
        </p>
        <p>
        <pre><code class="language-javascript">
// Load the container 'List'
let listId = '...';
let myList = List.get(listId);

// Select myList, and get all Note titles for myList:
let titleStream = myList(()=>{
   return Note.all().map((n)=>n.title));
});

// Assuming GET.js, this will result in JSON of Note titles:
titleStream;
            </code></pre>
        </p>
        <p>
            Or, the most compact form of same above statements:
        </p>
        <p>
        <pre><code class="language-javascript">
let listId = '...';
List.get(listId)(()=>Note.all().map((n)=>n.title)));
        </code></pre>
        </p>
        <p>
            Keep in mind that when working with containers in <a href="/endpoints/dynamic">dynamic REST paths</a>,
            the container selection has already occurred.
        </p>
    </section>

    <!--
    <section>
        <h2><a name="links">Model Links</a></h2>

        <p>
            Certain cases call for model "links".

        </p>
    </section>
    -->

    <section>
        <h2><a name="errors">Common Error Handling</a></h2>

        <p>
            In several examples above, note that <code>null</code> or <code>undefined</code>
            is not used to represent the absence of a result -- for example <code>List.get</code> and
            <code>Article.slug</code> never return a null/undefined value.
        </p>
        <p>
            Instead, an exception is thrown if there is no result.  This exception can be left "uncaught"
            and therefore propagated up to a view setup for <a href="/endpoints/errors">routing errors</a>.
            Or it can be specifically caught using a special nomenclature:
        </p>
        <p>
        <pre><code class="language-javascript">
let thingId = '....';
let thing = null;
try {
    thing = Thing.get(thingId);
} catch ($NotFound){
    // At this point we've specifically caught $NotFound,
    // as opposed to catching an unrelated error/exception.
    thing = new Thing();
}
// At this point 'thing' is always defined.
thing.updateField = 'x';
        </code></pre>
        </p>
    </section>
</article>


{{/content}}
{{/layout}}
