
{{% partial /_layout }}

{{<layout}}
{{$content}}

<article>
    <header>
        <h1>Suppliers</h1>

        <p>
            Learn about sharing and reusing values across multiple scripts and views.
        </p>
    </header>

    <section>
        <p>
            Suppliers are scripts which export one or more named values, for the sole purpose of
            having those values imported by another script -- either by another supplier,
            a <a href="/endpoints/js">JS endpoint</a>, or a <a href="/endpoints/mustache">Mustache endpoint</a>.
            Suppliers allow for reusing values and functions, as well as caching (via Site Suppliers).
            All values exported by suppliers exist in the module 'ðŸ“¤'.
        </p>
        <p>
            A general best practice is to keep supplier scripts very small and purpose specific.
            If you're exporting more than a few values out of a single supplier script,
            then it's likely worth breaking it out into multiple supplier scripts.
            Keeping supplier scripts small and purpose specific will enhance
            readability, performance, and maintainability.
        </p>
    </section>

    <section>
        <h2>Supplier Types and Exported Values</h2>

        <p>
            There are several types of suppliers.
            Choosing a supplier type depends on its purpose and allowed values.
            Supplier .js files always begin with a special prefix for its type.
            The remaining filename is for documentation purposes only, and
            typically indicates what is being exported or why.
        </p>

        <p>
            <i>By default suppliers only allow read only persistence operations.</i>
        </p>

        <h3>Site Supplier</h3>
        <p>
            <code>ðŸ“¤âˆžName.js</code>.
            Allowed exports: Primitives (String, Number, Boolean), Map/Object of Primitives,
            a single instance of a <a href="/scripting/models">Model</a>, or a <a href="/scripting/queries">Query</a>.
        </p>
        <p>
            Because Site Suppliers are only evaluated when needed (not every request),
            if a Model instance is exported, then its value may not contain the most
            recent data, and it is not modifiable.
        </p>

        <h3>Request Supplier</h3>
        <p>
            <code>ðŸ“¤~Name.js</code>
            Request Suppliers allow the same exports and capabilities
            as Site Suppliers -- the only difference is they are
            evaluated on every request, and are never cached.
        </p>
        <p>
            Because Request Suppliers are evaluated on every request,
            if a Model instance is exported, then its value is always "live"
            and modifiable by the endpoint which uses the supplied value.
        </p>

        <h3>Function Supplier</h3>
        <p>
            <code>ðŸ“¤{}Name.js</code>.
            Allowed exports: "Utility" functions only.  Function Suppliers
             have very limited functionality. They may not import anything (not even other suppliers).
            Their primary purpose is to provide functions that perform <i>calculations or transformations</i>
            on parameters.
        </p>
    </section>

    <section>
        <h2>Persistence Option</h2>

        <p>
            By default scripting logic inside of a supplier is read only.
            New models may not be constructed or persisted.
            There certain cases however when it can be useful to create and persist a model if it doesn't exist.
            To perform persistence within a supplier, the exported value must be a zero argument callback.
            The <i>result</i> of the callback will be used as the supplied value.
        </p>

        <p>
            In the following example the supplied value will be either an existing or new <code>TheModel</code>.
        </p>
        <p>
        <code>/something/{slug}/ðŸ“¤âˆžGetOrCreateValue.js</code>
        <pre><code class="language-javascript">
let callback = ()=>{
    try {
        return TheModel.slug($slug).get();
    } catch ($NotFound){
        return new TheModel().slug($slug);
    }
};

export {callback as TheValue};
            </code></pre>
        </p>
    </section>

    <section>
        <h2>File Location / Export Scope</h2>
        <p>
            The path location of a supplier file influences the scope
            of where its exported values are visible.
            Only scripts in the same directory, <i>or</i> descendant
            directories, have access to the exported values of a supplier.
        </p>
        <p>
            <code>/product/{productSlug}/ðŸ“¤~GetProduct.js</code>
            <pre><code class="language-javascript">
let product = Product.slug($productSlug).get();

export {product as Product};
            </code></pre>
        </p>
        <p>
            In the above example <code>Product</code> is the resulting value exported.
            It is available from the module named 'ðŸ“¤', for all scripts
            inside <code>/product/{productSlug}/*</code>, <i>and</i> any descendant directories.
            For example the Mustache file <code>/product/{productSlug}/related/index.mustache</code>
            would be able import the <code>Product</code> value.
        </p>

        <h3>Dynamic Paths</h3>
        <p>
            Suppliers are based on paths, including dynamic paths.  This extends to cached values as well.
            For example, a supplier at <code>/account/{account}/ðŸ“¤âˆžMySupplier.js</code>, would export and cache
            different values for <code>GET /account/1234/something</code> versus
            <code>GET /account/5678/something</code>.  If for some reason this is not desired, simply
            place the supplier at an earlier path, for example <code>/account/ðŸ“¤âˆžMySupplier.js</code>.
        </p>
    </section>

    <section>
        <h2>Importing Values</h2>

        <p>
            Regardless of where the supplier exists in the path hierarchy, and regardless of the supplier's file name,
            all supplier values are located in the module named 'ðŸ“¤'.  This creates a simple flat namespace for
            importing named values.
        </p>

        <p>
        <pre><code class="language-javascript">
// Importing specific values:
import {Something, Other, That} from 'ðŸ“¤';
        </code></pre>
        </p>
    </section>

    <section>
        <h1>Endpoint Specific and Pinned Suppliers</h1>

        <h3>Endpoint Specific Supplier</h3>
        <p>
            Because suppliers follow the hierarchical REST structure, they have varying levels of specificity for an endpoint.
            The most specific supplier is one with the same name as the endpoint itself.
            For example, an endpoint named <code>index.mustache</code>
            may also have a supplier named <code>ðŸ“¤~index.js</code>.
            As the most specific supplier, only <code>index.mustache</code> may access values exported by <code>ðŸ“¤index.js</code>.
        </p>

        <h3><a name="strict">Pinned Supplier</a></h3>
        <p>
            An extension to an endpoint specific supplier is a "pinned" supplier.
            Indicate a pinned supplier with the pin emoji, e.g. <code>ðŸ“¤~ðŸ“Œindex.js</code>.
            Pinned suppliers may be used to hide <i>or</i> re-expose broader/earlier supplied values.
        </p>
        <p>
            This is especially useful where more strict separation of concerns
            are desired, for example in the case of <a name="/endpoints/mustache#soc">Mustache endpoints</a>.
            The JavaScript developer may want to ensure that regardless of any suppliers along the REST path,
            only very explicit / strictly supplied values are visible to the Mustache file.
        </p>
    </section>

</article>


{{/content}}
{{/layout}}
