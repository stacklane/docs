<!--TEMPLATE mustache-->
{{% partial /_layout }}

{{< layout}}

{{$title}}Query Scripting{{/title}}

{{$content}}

<article>
    <header>
        <h1>Query Scripting</h1>

        <p>
            Learn about querying for models with chainable filters.
        </p>
    </header>

    <section>
        <p>
            Stacklane uses method chaining to define the criteria of returned query results.
            In general with method chaining <i>order matters</i> &mdash;; for example, field filters must be defined
            before calling <code>limit</code>.
        </p>
        <p>
            The results of a query are generally "used" outside of the script itself.  For example,
            a <a href="/endpoints/mustache">Mustache endpoint</a> may iterate over a query given by a
            <a href="/scripting/suppliers">supplier</a> to display results as HTML.
        </p>
    </section>

    <section>
        <h2><a name="all">all()</a></h2>

        <p>
            To query all models of a type, without any filters, use the <code>all()</code> method.
            For example, <code>Note.all()</code>.
            By default results will be returned from oldest to newest,
            however this can be reversed from newest to oldest by adding <code>desc()</code>,
            e.g. <code>Note.all().desc()</code>.
        </p>
    </section>

    <section>
        <h2><a name="fields">Field Filters</a></h2>

        <p>
            All queries besides <code>all()</code> start with a field filter.
            Multiple field filters may be chained together.
            Keep in mind that field filters are effectively <b>and</b> conditions.
        </p>

        <h3>eq</h3>
        <p>
            <code>Article.title('theTitle')</code>
        </p>

        <h3>gt</h3>
        <p>
            <code>Article.created_gt(new Date(2000))</code>
        </p>

        <h3>gte</h3>
        <p>
            <code>Product.price_gte(30)</code>
        </p>

        <h3>lt</h3>
        <p>
            <code>Article.created_gt(new Date(2000)).created_lt(new Date(2010))</code>
        </p>

        <h3>lte</h3>
        <p>
            <code>Product.price_gte(30).price_lte(40)</code>
        </p>
    </section>

    <section>
        <h2><a name="ordering">asc()/desc()</a></h2>

        <p>
            All model types have a <a href="/models/ordering">natural order</a>.
            To reverse the natural ordering, use asc() / desc(),
            such as  <code>Note.all().desc()</code>.
        </p>
    </section>

    <section>
        <h2><a name="filter">filter(function)</a></h2>
        <p>
            The callback function to <code>filter</code> returns a <code>boolean</code>
            that indicates whether the
            item should be included in the results (return false to exclude an entry).
            This should generally be used as a last resort -- specific equality and inequality field
            filters should be preferred both for code compactness and performance.
        </p>
    </section>

    <section>
        <h2><a name="limit">limit(number)</a></h2>

        <p>
            Limits the results of a query.
        </p>
    </section>

    <section>
        <h2><a name="map">map(function)</a></h2>
        <p>
            The callback function to <code>map</code> <i>transforms</i> the current stream element
            into a map.  This is often used to transform a model to a JSON object literal.
            It should be the last method in a chain.
        </p>
        <p>
        <pre><code class="language-javascript">
let titlesOnly = Article.all().map(article=>({title:article.title}));
        </code></pre>
        </p>
    </section>

    <section>
        <h2><a name="map">flatMap(function)</a></h2>
        <p>
            The callback function to <code>flatMap</code> <i>transforms</i> the current stream element
            into an array. It should be the last method in a chain.
        </p>
    </section>

    <section>
        <h2><a name="map">distinct()</a></h2>
        <p>
            Using the results from either <code>map</code> or <code>flatMap</code>,
            creates new results that contain only unique values.
        </p>
        <p>
        <pre><code class="language-javascript">
let distinctTitleCount = Article.all()
    .map(article=>({title:article.title}))
    .distinct()
    .count();
        </code></pre>
        </p>
    </section>

    <section>
        <h2><a name="get">get()</a></h2>

        <p>
            Returns a single result (effectively <code>limit(1)</code>).
            If there is no result, then a <code>$ModelNotFound</code>
            exception is generated, similar to loading a model by GUID.
        </p>
    </section>

    <section>
        <h2><a name="modify">modify(function)</a></h2>

        <p>
            The callback function to <code>modify</code>
            receives a <a href="/model/">Model</a> as its parameter,
            and does not expect any return value.
            This should only be used to update fields, or <code>remove()</code> models in bulk.
            It is only available during <code>POST</code>, <code>PUT</code>, <code>DELETE</code>.
        </p>

        <p>
            It is not required that every Model be modified, for example if it doesn't satisfy some condition.
            However consider using <code>filter(...)</code> in the case where there are well defined conditions
            that must be met before updating a model.  This will also keep your modify function simpler.
        </p>

        <p>
            This method works with full Model instances, and should therefore not be used in conjunction with
            <code>map(..)</code>.
        </p>

        <h3>Semi-Asynchronous</h3>
        <p>
            For bulk operations the first 10 updates will occur synchronously, before the method returns
            (before the request ends).  From a user standpoint this means that up to 10 results will be modified
             before they view the results or next page.
            Any results beyond the first 10 are processed asynchronously in batches, meaning there could be a
            short delay for a user to see the result of changes to larger batches.
            This "semi-asynchronous" approach strikes a balance between user expectations on more common (small) operations,
            while making sure the request time is at a minimum for larger operations.
        </p>
    </section>

    <section>
        <h2><a name="unique">Unique Value Queries</a></h2>

        <p>
            Query <a href="/models/fields#unique">unique</a> fields and <a href="/models/fields#uid">UID</a>
            fields as you would any other type of equality query.
            Assuming a model named <code>Article</code> and a UID field named "slug":
        </p>
        <p>
        <pre><code class="language-javascript">
let slugId = '....';
let found = Article.slug(slugId).get();
// Because of error handling, 'found' is always defined at this point
        </code></pre>
        </p>
    </section>

</article>

{{/content}}
{{/layout}}
