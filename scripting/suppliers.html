<!--TEMPLATE mustache-->
{{% partial /_layout }}

{{< layout}}

{{$title}}Suppliers{{/title}}

{{$content}}

<article>
    <header>
        <h1>Suppliers</h1>

        <p>
            Learn about sharing and reusing values across multiple scripts and views.
        </p>
    </header>

    <section>
        <p>
            Suppliers are scripts which export one or more named values, for the sole purpose of
            having those values imported by another script -- either by another supplier,
            a <a href="/endpoints/js">JS endpoint</a>, or a <a href="/endpoints/mustache">Mustache endpoint</a>.
            Suppliers allow for reusing values and functions.
            All values exported by suppliers exist in the module 'ðŸ“¤'.
        </p>
        <p>
            A general best practice is to keep supplier scripts very small and purpose specific.
            If you're exporting more than a few values out of a single supplier script,
            then it's likely worth breaking it out into multiple supplier scripts.
            Keeping supplier scripts small and purpose specific will enhance
            readability, performance, and maintainability.
        </p>

        <p class="alert alert-info small" role="alert">
            Suppliers aren't the only way to share values across many endpoints.
            <a href="/endpoints/#dynamic">Dynamic path parameters</a> which load models will
            provide the models to all suppliers and endpoints.
        </p>
    </section>

    <section>
        <h2><a name="types">Supplier Types</a></h2>

        <p>
            Choosing a supplier type depends on its purpose and allowed values.
            Supplier .js files always begin with a special prefix for its type.
            The remaining filename is for documentation purposes only, and
            typically indicates what is being exported or why.
        </p>

        <h3>Request Supplier</h3>
        <p>
            <code>ðŸ“¤Name.js</code>
            Allowed exports: Primitives (String, Number, Boolean), Map/Object of Primitives,
            a single instance of a <a href="/scripting/models">Model</a>, or a <a href="/scripting/queries">Query</a>.
        </p>
        <p>
            Only model read/query operations are allowed within the supplier.
            However the endpoint finally using the supplied value may itself perform write operations
            if allowed by the endpoint.
        </p>

        <h3>Function Supplier</h3>
        <p>
            <code>ðŸ“¤{}Name.js</code>.
            Allowed exports: "Utility" functions only.  Function Suppliers
             have very limited functionality. They may not import anything (not even other suppliers).
            Their primary purpose is to provide functions that perform <i>calculations or transformations</i>
            on parameters.
        </p>
    </section>

    <!-- this was for app scoped only, but we may want to allow it for event scoped ?
    <section>
        <h2><a name="persistence">Persistence Option</a></h2>

        <p>
            By default scripting logic inside of a supplier is read only.
            New models may not be constructed or persisted.
            There certain cases however when it can be useful to create and persist a model if it doesn't exist.
            To perform persistence within a supplier, the exported value must be a zero argument callback.
            The <i>result</i> of the callback will be used as the supplied value.
        </p>

        <p>
            In the following example the supplied value will be either an existing or new <code>TheModel</code>.
        </p>
        <p>
        <code>/something/{slug}/ðŸ“¤âˆžGetOrCreateValue.js</code>
        <pre><code class="language-javascript">
let callback = ()=>{
    try {
        return TheModel.slug($slug).get();
    } catch ($NotFound){
        return new TheModel().slug($slug);
    }
};

export {callback as TheValue};
            </code></pre>
        </p>
    </section>
    -->

    <section>
        <h2><a name="scope">Export Scope</a></h2>
        <p>
            The path location of a supplier file influences the scope
            of where its exported values are visible.
            Only scripts in the same directory, <i>or</i> descendant
            directories, have access to the exported values of a supplier.
        </p>
        <p>
            <code>/product/{productSlug}/ðŸ“¤GetProduct.js</code>
            <pre><code class="language-javascript">
let product = Product.slug($productSlug).get();

export {product as Product};
            </code></pre>
        </p>
        <p>
            In the above example <code>Product</code> is the resulting value exported.
            It is available from the module named 'ðŸ“¤', for all scripts
            inside <code>/product/{productSlug}/*</code>, <i>and</i> any descendant directories.
            For example the Mustache file <code>/product/{productSlug}/related/index.html</code>
            would be able import the <code>Product</code> value.
        </p>

        <h3>Dynamic Paths</h3>
        <p>
            Suppliers are based on paths, including dynamic paths.  This extends to cached values as well.
            For example, a supplier at <code>/account/{account}/ðŸ“¤MySupplier.js</code>, would export and cache
            different values for <code>GET /account/1234/something</code> versus
            <code>GET /account/5678/something</code>.  If for some reason this is not desired, simply
            place the supplier at an earlier path, for example <code>/account/ðŸ“¤MySupplier.js</code>.
        </p>
    </section>

    <section>
        <h2><a name="importing">Importing Values</a></h2>

        <p>
            Regardless of where the supplier exists in the path hierarchy, and regardless of the supplier's file name,
            all supplier values are located in the module named 'ðŸ“¤'.  This creates a simple flat namespace for
            importing named values.
        </p>

        <p>
        <pre><code class="language-javascript">
// Importing specific values:
import {Something, Other, That} from 'ðŸ“¤';
        </code></pre>
        </p>
    </section>

    <section>
        <h2>Endpoint Specific and Pinned Suppliers</h2>

        <h3>Endpoint Specific Supplier</h3>
        <p>
            Because suppliers follow the hierarchical REST structure, they have varying levels of specificity for an endpoint.
            The most specific supplier is one with the same name as the endpoint itself.
            For example, an endpoint named <code>index.html</code>
            may also have a supplier named <code>ðŸ“¤index.js</code>.
            As the most specific supplier, only <code>index.html</code> may access values exported by <code>ðŸ“¤index.js</code>
            (however <code>index.html</code> may also access other in-scope suppliers).
        </p>

        <h3><a name="strict">Pinned Supplier</a></h3>
        <p>
            An extension to an endpoint specific supplier is a "pinned" supplier.
            Indicate a pinned supplier with the pin emoji, e.g. <code>ðŸ“¤ðŸ“Œindex.js</code>.
            Pinned suppliers may be used to hide <i>or</i> re-expose broader/earlier supplied values.
        </p>
        <p>
            This is especially useful where more strict separation of concerns
            are desired, for example in the case of <a href="/endpoints/mustache#soc">Mustache endpoints</a>.
            The JavaScript developer may want to ensure that regardless of any suppliers along the REST path,
            only very explicit / strictly supplied values are visible to the Mustache file.
        </p>
    </section>

</article>


{{/content}}
{{/layout}}
